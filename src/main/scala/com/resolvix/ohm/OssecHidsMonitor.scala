package com.resolvix

import java.time._
import java.time.chrono.{ChronoLocalDate, ChronoLocalDateTime}
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit
import java.lang.Thread
import java.util.NoSuchElementException

import com.resolvix.log.Loggable
import com.resolvix.ohm.OssecHidsMonitor.{AvailableModuleType, ModuleType}
import com.resolvix.ohm.api.AlertStatus
import com.resolvix.ohm.dao.api.OssecHidsDAO
import com.resolvix.ohm.module.api.{Module, ModuleDescriptor, Result}
import com.resolvix.ohm.module.endpoint.api.EndpointResult
import com.resolvix.ohm.module.endpoint.jira.JiraEndpointDescriptor
import com.resolvix.ohm.module.endpoint.sink.{SinkEndpoint, SinkEndpointDescriptor}
import com.resolvix.ohm.module.endpoint.text.{TextEndpoint, TextEndpointDescriptor}
import com.resolvix.ohm.module.stage.api.StageResult
import com.resolvix.ohm.module.stage.newstage.NewStage
import org.apache.commons.cli

import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scala.concurrent.{ExecutionContext, Future, Promise}
import scala.util.{Failure, Success, Try}
import scala.concurrent.ExecutionContext.Implicits.global

package ohm {

  import OssecHidsMonitor.ActiveModule

  import scala.util.control.NonFatal

  /**
    *
    */
  object OssecHidsMonitor
    extends Loggable {

    /**
      * The ActiveModule class is intended to wrap active module instances
      * with application mainframe state, including but not limited to -
      *
      * (1) whether the module is activated for use by OHM;
      *
      * @param module
      * the module
      *
      * @param isEnabled
      * true, if the module is enabled; false, otherwise
      *
      * @param updateModuleAlertStatus
      * a reference to the function to be invoked upon an update to an alert
      * status for a module
      *
      * @param logFailure
      * a reference to the function to be invoked upon the need to log a
      * failure
      *
      * @tparam I
      * the input data type for the module
      *
      * @tparam O
      * the output data type for the module
      *
      * @tparam R
      * the data type of the result generated by the module, being a data type
      * derived from [[Result]].
      */
    class ActiveModule[I, O, R <: Result](

      //
      //  The module.
      //
      private val module                 : Module[I, O, R],

      //
      //  Whether the module is enabled; this property is redundant if the
      //  definition of an active module is a module that is present, available
      //  and active.
      //
      //@deprecated
      private val isEnabled              : Boolean,

      //
      //  The function to execute to perform an update
      //  to the underlying data store in respect of a module
      //  alert status.
      //
      //  This parameter is intended to be a callback to the
      //  host application for modules to enable them to persist
      //  to the data store without having to make reference
      //  to the mechanics of storage.
      //
      private val updateModuleAlertStatus: Option[Function[AlertStatus, Try[Boolean]]],

      //
      //  The function to execute to log a failure.
      //
      //  This parameter is intended to be a callback to the
      //  host application for modules to enable them to log messages
      //  without having to make reference to the mechanics of logging.
      //
      private val logFailure             : Option[Function[Throwable, Try[Boolean]]]

    ) extends Module[I, O, R]
      with Loggable {
      //
      //
      //
      private val mapPromiseModuleAlertStatus: mutable.Map[Int, Promise[AlertStatus]]
      = new mutable.HashMap[Int, Promise[AlertStatus]]

      //
      //
      //
      private val mapFutureModuleAlertStatus: mutable.Map[Int, Future[AlertStatus]]
      = new mutable.HashMap[Int, Future[AlertStatus]]

      /**
        *
        * @return
        */
      def onComplete: Function[Try[AlertStatus], Unit] = {
        case Success(moduleAlertStatus: AlertStatus) =>
          log.debug(
            "AID: "
              + moduleAlertStatus.getId
              + ", MID: "
              + moduleAlertStatus.getModuleId
              + ", REF: "
              + moduleAlertStatus.getReference
              + ", SID: "
              + moduleAlertStatus.getStatusId
          )

          updateModuleAlertStatus.get(moduleAlertStatus)

        /*case Failure(e: ModuleAlertProcessingException[api.Alert, ModuleAlertStatus] @unchecked) => {
        updateModuleAlertStatus(
          new FailureModuleAlertStatus(
            e.getAlert,
            e.getModule
          )
        )
        logFailure(e)
      }*/

        case Failure(t: Throwable) => {
          logFailure.get(t)
        }
      }

      def appendPromiseModuleAlertStatus(
        alert                   : Alert,
        promiseModuleAlertStatus: Promise[AlertStatus]
      ): Try[Boolean] = {
        try {
          //
          //  Associate the future module alert status with the relevant
          //  module pending receipt of a referential callback.
          //
          mapPromiseModuleAlertStatus.put(
            alert.getId,
            promiseModuleAlertStatus
          )

          //
          //  Configure the behaviour of the future module alert status upon
          //  notice from the relevant module.
          //
          promiseModuleAlertStatus.future
            .onComplete(this.onComplete)
          Success(true)
        } catch {
          case t: Throwable =>
            Failure(t)
        }
      }

      override def close(): Try[Boolean] = {
        module.close()
      }

      override def flush(): Try[R] = {
        module.flush()
      }

      def getDescription: String = {
        module.getDescriptor.getDescription
      }

      def getHandle: String = {
        module.getDescriptor.getHandle
      }

      override def getId: Int = {
        module.getId
      }

      override def initialise(): Try[Boolean] = {
        module.initialise()
      }

      override def consume(input: I): Try[Boolean] = {
        module.consume(input)
      }

      override def consume(result: R): Try[Boolean] = {
        //
        // TODO Implement consume(R) to update values of type StageResult
        //
        Success(true)
      }

      override def getDescriptor: ModuleDescriptor[I, O, R] = {
        module.getDescriptor
      }

      override def open(): Try[Boolean] = {
        module.open()
      }

      override def terminate(): Try[Boolean] = {
        module.terminate()
      }
    }

    /**
      * The ProducerConsumer class provides a template for an outgoing message
      * queue for alerts (the "alert producer"), and an incoming message queue
      * for alert status updates and reports (the "alert status consumer").
      *
      * @tparam A
      *
      * @tparam M
      */
    /*class RunnableProducerConsumer[A <: Alert, M <: AlertStatus]
    extends com.resolvix.ccs.impl.RunnableProducerConsumer[RunnableProducerConsumer[A, M], A, M]
  {
    override def doConsume(c: M): Try[Boolean] = ???

    override def doProduce(): Try[A] = ???
  }*/

    //
    //
    //
    type AvailableModuleType = module.api.ModuleDescriptor[_ <: module.api.Alert, _ <: AlertStatus, _ <: Result]

    //
    //
    //
    type ModuleType = module.api.Module[_ <: module.api.Alert, _ <: AlertStatus, _ <: Result]

    //
    //
    //
    type EndpointType = module.endpoint.api.Endpoint[_ <: module.api.Alert, _ <: AlertStatus, _ <: EndpointResult]

    //
    //
    //
    type StageType = module.stage.api.Stage[_ <: module.api.Alert, _ <: AlertStatus, _ <: StageResult[_]]

    //
    //  Constant: provides a list of built-in modules for OHM.
    //
    private final val BuiltInModules: List[AvailableModuleType] = List[AvailableModuleType](
      JiraEndpointDescriptor,
      TextEndpointDescriptor,
      SinkEndpointDescriptor
    )

    //
    //  Constant: provides the command line options for OHM.
    //
    private final val CommandLineOptions: cli.Options = {
      val configOption: cli.Option = cli.Option.builder("c")
        .longOpt("config")
        .desc("The configuration file")
        .hasArg()
        .build()

      val helpOption: cli.Option = cli.Option.builder("h")
        .longOpt("help")
        .desc("Display this information")
        .build()

      val listOption: cli.Option = cli.Option.builder("l")
        .longOpt("list")
        .desc("List available modules")
        .build()

      val fromOption: cli.Option = cli.Option.builder("f")
        .longOpt("from")
        .desc("Start of the period over which OSSEC HIDS alerts "
          + "are to be processed")
        .hasArg()
        .build()

      val toOption: cli.Option = cli.Option.builder("t")
        .longOpt("to")
        .desc("End of the period over which OSSEC HIDS alerts "
          + "are to be processed")
        .hasArg()
        .build()

      (new cli.Options)
        .addOption(helpOption)
        .addOption(listOption)
        .addOption(configOption)
        .addOption(fromOption)
        .addOption(toOption)
    }

    //
    //  Constant: specifies the default time zone for OHM at runtime.
    //
    private final val DefaultZoneId: ZoneId = ZoneId.systemDefault()

    //
    //  Constant: specifies the default time zone offset for OHM at runtime.
    //
    private final val DefaultZoneOffset: ZoneOffset = ZonedDateTime.now(DefaultZoneId).getOffset

    //
    //  Constant: provides the date time formatter for ISO-8601 local dates
    //  (expressed without reference to a specific time zone).
    //
    private final val IsoDateFormatter: DateTimeFormatter = DateTimeFormatter.ISO_LOCAL_DATE

    //
    //  The list of available modules for OHM determined at runtime by reference
    //  to -
    //
    //  (1) the list of built-in modules;
    //
    //  (2) the results of any reflective scan of packages and classes available
    //      to OHM through the classpath;
    //
    //  (3) packages and classes expressly referenced in the OHM configuration
    //      file.
    //
    private val availableModules: List[AvailableModuleType] = enumerateAvailableModules();

    /**
      * A placeholder for a function responsible for enumerating the available
      * built in and plugged-in modules, by reference to -
      *
      * (1) the list of built-in modules;
      * (2) the results of any reflective scan of packages and classes available
      * to OHM through the classpath; and
      * (3) packages and classes expressly referenced in the OHM configuration
      * file.
      *
      * @return
      * a list of available modules
      */
    private def enumerateAvailableModules(): List[AvailableModuleType] = BuiltInModules

    /**
      * Interprets the {@literal <date>} argument supplied to OHM using the
      * `from` or `-f` command line switch.
      *
      * @param dateTime
      * the string representing the actual date and time, or a relative date
      * and time, from which OSSEC HIDS alert processing should take place
      *
      * @return
      * a { @link LocalDateTime} object
      */
    private def determineFromDateTime(
      dateTime: String
    ): Try[LocalDateTime] = {

      try {
        dateTime match {
          case "today" =>
            Success(
              LocalDateTime.now()
                .truncatedTo(ChronoUnit.DAYS)
            )

          case "yesterday" =>
            Success(
              LocalDateTime.now()
                .minusDays(1)
                .truncatedTo(ChronoUnit.DAYS)
            )

          case s: String =>
            Success(
              LocalDate.parse(s, IsoDateFormatter)
                .atStartOfDay()
            )

          case _ =>
            Success(
              LocalDateTime.now()
                .truncatedTo(ChronoUnit.DAYS)
            )
        }
      } catch {
        case t: Throwable =>
          Failure(t)
      }
    }

    /**
      * Interprets the {@literal <date>} argument supplied to OHM using the
      * `to` or `-t` command line switch.
      *
      * @param dateTime
      * the string representing the actual date and time, or a relative date
      * and time, to which OSSEC HIDS alert processing should take place
      *
      * @return
      * a { @link LocalDateTime} object
      */
    private def determineToDateTime(
      dateTime: String
    ): Try[LocalDateTime] = {
      try {
        dateTime match {
          case "now" =>
            Success(LocalDateTime.now())

          case s: String =>
            Success(
              earlierOf(
                LocalDate.parse(s, IsoDateFormatter)
                  .plusDays(1)
                  .atStartOfDay(),
                LocalDateTime.now()
              )
            )

          case _ =>
            Success(
              LocalDateTime.now()
            )
        }
      } catch {
        case t: Throwable =>
          Failure(t)
      }
    }

    /**
      * Displays OHM command line help.
      */
    def displayHelp(): Unit = {
      val helpFormatter: cli.HelpFormatter = new cli.HelpFormatter
      helpFormatter.printHelp("ossec-hids-monitor", "", CommandLineOptions, "", true)
    }

    /**
      * Displays the list of available modules.
      */
    def displayModules(): Unit = {
      for (availableModule <- availableModules) {
        println(
          availableModule.getHandle
            + " "
            + availableModule.getDescription
        )
      }
    }

    def dispatch(
      args: Array[String]
    ): Unit = {
      //
      //
      //
      val commandLineParser: cli.CommandLineParser = new cli.DefaultParser()

      //
      //
      //
      val commandLine: cli.CommandLine = commandLineParser.parse(
        CommandLineOptions,
        args
      )

      commandLine.getOptions.mkString(" ") match {
        case "help" =>
          displayHelp()

        case "list" =>
          displayModules()

        case _ =>
          execute(commandLine)
      }
    }

    def execute(
      commandLine: cli.CommandLine
    ): Unit = {

      //
      //
      //
      val fromDateTime: LocalDateTime = determineFromDateTime(
        commandLine.getOptionValue("from")
      ) match {
        case Success(localDateTime: LocalDateTime) =>
          localDateTime

        case Failure(t: Throwable) =>
          throw t
      }

      //
      //
      //
      val toDateTime: LocalDateTime = determineToDateTime(
        commandLine.getOptionValue("to")
      ) match {
        case Success(localDateTime: LocalDateTime) =>
          localDateTime

        case Failure(t: Throwable) =>
          throw t
      }

      //
      //
      //
      val modules: List[AvailableModuleType] = List[AvailableModuleType]()

      //
      //
      //
      val configuration: Map[String, Any] = Map[String, Any]()

      //
      //
      //
      val ossecHidsDAO: OssecHidsDAO = null

      //
      //
      //
      new OssecHidsMonitor(ossecHidsDAO).execute(
        modules,
        configuration,
        fromDateTime,
        toDateTime
      )
    }

    /**
      * Returns the earlier of the left hand side, and right hand side temporal
      * values.
      *
      * @param lhs
      * the left hand side temporal value.
      *
      * @param rhs
      * the right hand side temporal value.
      *
      * @tparam S
      * the type of the left hand side temporal value.
      *
      * @tparam T
      * the type of the right hand side temporal value.
      *
      * @tparam U
      * the type of the result.
      *
      * @return
      * the earlier of the left and right hand side temporal values.
      *
      */
    private def earlierOf[
    S <: ChronoLocalDateTime[_ <: ChronoLocalDate],
    T <: ChronoLocalDateTime[_ <: ChronoLocalDate],
    U <: ChronoLocalDateTime[_ <: ChronoLocalDate]
    ](
      lhs: S,
      rhs: T
    ): U = {
      if (lhs.compareTo(rhs) <= 0x00) {
        lhs.asInstanceOf[U]
      } else {
        rhs.asInstanceOf[U]
      }
    }

    def getAvailableModules: List[AvailableModuleType] = {
      BuiltInModules
    }

    def getAvailableModules(
      filter: Function[AvailableModuleType, Boolean]
    ): List[AvailableModuleType] = {
      (
        for (module: AvailableModuleType <- BuiltInModules if filter.apply(module))
          yield {
            module
          }
        ).toList
    }

    def main(
      args: Array[String]
    ): Unit = {
      dispatch(args)
    }
  }

  /**
    *
    * @param ossecHidsDAO
    */
  class OssecHidsMonitor(
    //
    //
    //
    ossecHidsDAO: OssecHidsDAO
  ) extends Loggable {

    type ActiveModuleType = ActiveModule[module.api.Alert, api.AlertStatus, module.api.Result]

    def logFailure: PartialFunction[Throwable, Try[Boolean]] = {
      case (t: Throwable) => Success(true)
    }

    //
    //  The list of locations
    //
    private val locations: List[Location] = ossecHidsDAO.getLocations match {
      case Success(locations: List[Location]) =>
        locations

      case Failure(t: Throwable) =>
        List[Location]()
    }

    //
    //
    //
    private val locationMap: Map[Int, Location]
    = locations.map(
      (l: Location) => (l.getId, l)
    ).toMap

    //
    //
    //
    private val categories: List[Category] = ossecHidsDAO.getCategories match {
      case Success(categories: List[Category]) =>
        categories

      case Failure(t: Throwable) =>
        List[Category]()
    }

    //
    //
    //
    private val categoryMap: Map[Int, Category]
    = categories.map(
      (c: Category) => (c.getId, c)
    ).toMap

    //
    //
    //
    private val signatures: List[Signature] = ossecHidsDAO.getSignatures match {
      case Success(signatures: List[Signature]) =>
        signatures

      case Failure(t: Throwable) =>
        List[Signature]()
    }

    //
    //
    //
    private val signatureMap: Map[Int, Signature]
    = signatures.map(
      (s: Signature) => (s.getRuleId, s)
    ).toMap

    //
    //
    //
    crossReferenceSignaturesAndCategories(
      signatureMap,
      categoryMap
    )

    def crossReferenceSignaturesAndCategories(
      signatureMap: Map[Int, Signature],
      categoryMap : Map[Int, Category]
    ): Unit = {
      val signatureCategoryMaplets: List[SignatureCategoryMaplet]
      = ossecHidsDAO.getSignatureCategoryMaplets match {
        case Success(signatureCategoryMaplets: List[SignatureCategoryMaplet]) =>
          signatureCategoryMaplets

        case Failure(t: Throwable) =>
          List[SignatureCategoryMaplet]()
      }

      val signatureCategoryListMap: mutable.Map[Int, ListBuffer[Category]]
      = mutable.Map[Int, ListBuffer[Category]]()

      val categorySignatureListMap: mutable.Map[Int, ListBuffer[Signature]]
      = mutable.Map[Int, ListBuffer[Signature]]()

      for (scm: SignatureCategoryMaplet <- signatureCategoryMaplets) {
        for (
          s: Signature <- signatureMap.get(scm.getRuleId);
          c: Category <- categoryMap.get(scm.getCategoryId)
        ) {
          val slb: ListBuffer[Signature] = categorySignatureListMap
            .getOrElseUpdate(scm.getCategoryId, ListBuffer[Signature]())

          val clb: ListBuffer[Category] = signatureCategoryListMap
            .getOrElseUpdate(scm.getRuleId, ListBuffer[Category]())

          slb :+ s
          clb :+ c
        }
      }

      for (s: Signature <- signatures) {
        try {
          val clb: ListBuffer[Category] = signatureCategoryListMap(s.getId)
          s.setCategories(clb.toList)
        } catch {
          case e: NoSuchElementException =>
          //
          //  Do nothing
          //
        }
      }

      for (c: Category <- categories) {
        try {
          val slb: ListBuffer[Signature] = categorySignatureListMap(c.getId)
          c.setSignatures(slb.toList)
        } catch {
          case e: NoSuchElementException =>
          //
          //  Do nothing
          //
        }
      }
    }

    /**
      * Register the instance with the requisite producer and consumer modules,
      * to setup the relevant 'Alert' and 'ModuleAlertStatus' message pipelines.
      *
      * @param instance
      * the instance to be registered with producer and consumer modules.
      *
      * @return
      *
      */
    def registerModules(
      instance: ModuleType
    ): Try[Boolean] = {
      /*
    //
    //  1.  Cross-register the service mainframe and the instance as consumers
    //      and producers of their respective data types.
    //
    val c: Consumer[_ <: module.api.Alert]
      = instance.getAlertConsumer

    val p: Producer[_ <: module.api.Result]
      = instance.getResultProducer

    //
    //  get the list of module handles for which the instance is expected
    //  to interact
    //

    val producerHandles: Iterable[String]
      = instance.getProducerHandles

    val consumerHandles: Iterable[String]
      = instance.getConsumerHandles

    producerHandles.foreach {
      (producerHandle: String) => {
        val consumer: Consumer[_ <: module.api.Country]
          = p.register(consumer)
        c.register(producerHandle)
      }
    }

    consumerhandles.foreach {
      (consumerHandle: String) => {
        val producer: Producer[_ <: module.api.Result]
          = p.register(consumerHandle)[String]
      }
    }

    //val m:

    c.register(
      this.producer
    )*/
      ???
    }

    /**
      *
      * @param modules
      *
      * @param configuration
      */
    def instantiateModules(
      modules      : List[AvailableModuleType],
      configuration: Map[String, Any]
    ): Unit = {

      modules.map {
        (m: AvailableModuleType) => {
          m.getModule(
            configuration.getOrElse(
              m.getHandle,
              Map[String, Any]()
            ).asInstanceOf[Map[String, Any]]
          ) match {
            case Success(i: ModuleType) =>
              registerModules(i) match {
                case Success(b: Boolean) =>
                //
                //  TODO: determine what to do with successful registration attempts
                //

                case Failure(t: Throwable) =>
                //
                //  TODO: determine what to do with failed registration attempts
                //
              }


            case Failure(t: Throwable) =>
            //
            //  TODO: determine what to do with failed instantiation attempts
            //
          }
        }
      }

    }

    /**
      *
      * @param modules
      *
      * @param configuration
      *
      * @param fromDateTime
      *
      * @param toDateTime
      */
    def execute(
      modules      : List[AvailableModuleType],
      configuration: Map[String, Any],
      fromDateTime : LocalDateTime,
      toDateTime   : LocalDateTime
    ): Unit = {
      //
      //
      //
      val alerts: List[Alert] = ossecHidsDAO.getAlertsForPeriod(
        0x01,
        fromDateTime,
        toDateTime
      ) match {
        case Success(alerts: List[_]) =>
          alerts.asInstanceOf[List[Alert]]

        case Failure(t: Throwable) =>
          List[Alert]()
      }

      // val ns: NewStage = new NewStage(ossecHidsDAO, locationMap, signatureMap)
    }

    /**
      *
      * @param moduleAlertStatus
      *
      * @return
      */
    private def updateModuleAlertStatus(
      moduleAlertStatus: AlertStatus
    ): Try[Boolean] = {
      log.debug("updateModuleAlertStatus: ")
      ossecHidsDAO.setModuleAlertStatus(
        moduleAlertStatus.getId,
        moduleAlertStatus.getModuleId,
        moduleAlertStatus.getReference,
        moduleAlertStatus.getStatusId
      )
      Success(true)
    }

    /**
      *
      * @param alerts
      *
      * @param modules
      *
      * @param configuration
      */
    def process(
      alerts       : List[module.api.Alert],
      modules      : List[AvailableModuleType],
      configuration: Map[String, Any]
    ): Unit = {

      val activeModules: List[ActiveModuleType] = modules.map(
        (am: AvailableModuleType) => new ActiveModuleType(
          am.getModule(configuration.toMap).get
            .asInstanceOf[Module[module.api.Alert, AlertStatus, module.api.Result]],
          false,
          Some(updateModuleAlertStatus),
          Some(logFailure)
        )
      )

      activeModules.foreach(
        (m: ActiveModuleType) => {
          m.initialise()
          m.open()
        }
      )

      for (
        alert: module.api.Alert <- alerts;
        activeModule: ActiveModuleType <- activeModules
      ) {

        try {
          val moduleAlertStatuses: List[AlertStatus]
          = ossecHidsDAO.getModuleAlertStatusesById(
            alert.getId
          ) match {
            case Success(moduleAlertStatuses: List[AlertStatus]) =>
              moduleAlertStatuses

            case Failure(t: Throwable) =>
              List[AlertStatus]()
          }

          val moduleAlertStatus: Option[AlertStatus]
          = moduleAlertStatuses.collectFirst[AlertStatus]({
            case (moduleAlertStatus: AlertStatus)
              if moduleAlertStatus.getModuleId == activeModule.getId =>
              moduleAlertStatus
          })

          if (moduleAlertStatus.isEmpty) {
            activeModule.consume(alert)

            /*match {
              case Success(er: EndpointResult) => {
                log.debug(er.getClass.getName())
                er.getAlertStatuses.map(
                  (as: AlertStatus) =>
                    updateModuleAlertStatus(as)
                )
              }

              case Success(sr: StageResult) => {
                log.debug(sr: )

              }

              case Success(r: Result) => {
                log.debug(r.getClass().getName())
              }

              case Failure(t: Throwable) =>
              //
              //  TODO: Log the failure
              //
            }*/
          }
        } catch {
          case t: Throwable =>
          //
          //  TODO: Log the failure
          //
        }
      }

      log.info("OssecHidsMonitor::process: alert processing complete")

      activeModules.foreach(
        (activeModule: ActiveModuleType) => {
          activeModule.close()
          activeModule.terminate()
        }
      )
    }
  }
}