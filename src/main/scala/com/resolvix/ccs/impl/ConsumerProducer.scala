package com.resolvix.ccs.impl

import com.resolvix.ccs.api
import com.resolvix.ccs.api.Configuration
import com.resolvix.mq.api.Writer

import scala.util.control.NonFatal
import scala.util.{Success, Try}

/**
  * Provides generic functionality relevant to an [[Actor]] that
  * consumes output, of type C, generated by one or more producers and
  * produces output, of type P, that is consumed by one or more
  * consumers.
  *
  * This functionality is intended to support the following use cases -
  *
  * <ol>
  * <li>form a stage in a multistage pipeline involving the
  *     translation of input of type C to output of type P; and</li>
  * <li>form an endpoint in which packets of type C are processed
  *     to form a result of type P.</li>
  * </ol>
  *
  * @tparam CP
  *   refers to the [[ConsumerProducer]] extending this trait
  *
  * @tparam C
  *   refers to the input type represented by C
  *
  * @tparam P
  *   refers to the output type represented by P
  */
trait ConsumerProducer[CP <: api.ConsumerProducer[CP, C, P], C, P]
  extends api.ConsumerProducer[CP, C, P]
{

  /**
    * Concrete implementation of a class applying the Consumer trait class to
    * enable classes using the ConsumerProducer trait to consume messages of
    * type C produced by a producer based on the Producer trait for messages
    * of type C.
    */
  protected class ConsumerC
    extends Consumer[C]
  {
    /**
      *
      * @return
      */
    override protected def getSelf: ConsumerC = this

    /**
      *
      * @param configuration
      *
      * @return
      */
    override def initialise(
      configuration: Configuration
    ): Try[Boolean] = {
      super.initialise(configuration)
    }
  }

  /**
    * Conrete implementation of a class applying the Producer abstract trait to
    * enable classes using the ConsumerProducer trait to produce messages of
    * type P consumed by a consumer based on the Consumer trait for messages of
    * type P.
    */
  protected class ProducerP
    extends Producer[P]
  {
    /**
      *
      * @return
      */
    override protected def getSelf: ProducerP = this

    /**
      *
      * @param configuration
      * @return
      */
    override def initialise(
      configuration: Configuration
    ): Try[Boolean] = {
      super.initialise(configuration)
    }
  }

  /**
    *
    * @return
    */
  protected def newConsumerC: api.Consumer[C] = new ConsumerC

  /**
    *
    * @return
    */
  protected def newProducerP: api.Producer[P] = new ProducerP

  /**
    *
    */
  private val consumerC: api.Consumer[C] = this.getConsumer

  /**
    *
    */
  private val producerP: api.Producer[P] = this.getProducer

  /**
    *
    * @return
    */
  def getConsumer: api.Consumer[C] = {
    if (consumerC != null)
      return consumerC

    newConsumerC
  }

  /**
    *
    * @return
    */
  def getProducer: api.Producer[P] = {
    if (producerP != null)
      return producerP

    newProducerP
  }

  override def register(consumer: api.Consumer[P]): Try[Boolean] = {
    getProducer.register(consumer)
  }

  override def register(producer: api.Producer[C]): Try[Boolean] = {
    getConsumer.register(producer)
  }

  private def crossregister[V](
    producer: api.Producer[V],
    consumer: api.Consumer[V]
  ): Try[Boolean] = {
    val triedRegistration: Try[Boolean] = producer.register(consumer)
    if (triedRegistration.isFailure)
      return triedRegistration
    consumer.register(producer)
  }

  private def crossunregister[V](
    producer: api.Producer[V],
    consumer: api.Consumer[V]
  ): Try[Boolean] = {
    val triedUnregistration: Try[Boolean] = producer.unregister(consumer)
    if (triedUnregistration.isFailure)
      return triedUnregistration
    consumer.unregister(producer)
  }

  /**
    *
    * @param producerConsumer
    * @tparam PC
    * @return
    */
  override def crossregister[CPPC <: api.ConsumerProducer[CPPC, P, C]](
    consumerProducerPC: CPPC
  ): Try[Boolean] = {

    val consumerP: api.Consumer[P] = consumerProducerPC.getConsumer

    val triedProducerConsumerCrossRegistration: Try[Boolean] = crossregister(getProducer, consumerP)
    if (triedProducerConsumerCrossRegistration.isFailure)
      return triedProducerConsumerCrossRegistration

    val producerC: api.Producer[C] = consumerProducerPC.getProducer

    val triedConsumerProducerCrossRegistration: Try[Boolean] = crossregister(producerC, getConsumer)
    if (triedConsumerProducerCrossRegistration.isFailure)
      return crossunregister(producerP, consumerP)

    Success(true)
  }
}